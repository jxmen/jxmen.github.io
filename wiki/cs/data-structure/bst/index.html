<!DOCTYPE html>
<html>
    <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- 참고: https://jekyllrb.com/docs/liquid/filters/ -->
    <title>Binary Search Tree - 박주영의 위키</title>

    <meta name="description" content="">
    <meta name="google-site-verification" content="xD2UvBTOH6xxBi9MseahHz4Nt9u2vYZbgY2wVo7Bdyc">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://jxmen.github.io/wiki/cs/data-structure/bst/">
    <link rel="alternate" type="application/rss+xml" title="박주영의 위키" href="https://jxmen.github.io/feed.xml">

    <meta property="og:type" content="website">
    <meta property="og:title" content="Binary Search Tree">
    <meta property="og:description" content="">
    <!---
    <meta property="og:image" content="https://jxmen.github.io/resource/johngrib.png">
    -->
    <meta property="og:url" content="https://jxmen.github.io/wiki/cs/data-structure/bst/">

    <meta name="google-site-verification" content="IoNEKzwdxuYHx0g2nEWusOJ2kK0ompxgUZ-evn27Vlk">

    <!--- 
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@" />
        <meta name="twitter:url" content="https://jxmen.github.io/wiki/cs/data-structure/bst/" />
        <meta name="twitter:title" content="Binary Search Tree" />
        <meta name="twitter:description" content="" />
    --->

    <!---
    <link rel="apple-touch-icon" sizes="57x57"        href="/resource/icon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60"        href="/resource/icon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72"        href="/resource/icon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76"        href="/resource/icon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114"      href="/resource/icon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120"      href="/resource/icon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144"      href="/resource/icon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152"      href="/resource/icon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180"      href="/resource/icon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/resource/icon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32"   href="/resource/icon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96"   href="/resource/icon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16"   href="/resource/icon/favicon-16x16.png">
    <link rel="manifest" href="/resource/icon/manifest.json">
    --->
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/resource/icon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">




</head>
<body>
<header class="header">
    <div>
        <a class="site-title" href="/">박주영의 위키</a>
    </div>
    <div>
        <a class="site-title-right" href="/about/">me</a>
    </div>
    <div>
        <a id="random-button" class="site-title-right">random</a>
    </div>
    <div>
        <!---<a class="site-title-right" href="/wiki/root-index/">index</a> --->
        <a class="site-title-right" href="/wiki/index/">index</a>
    </div>
</header>
<script async src="/js/shortcut.js"></script>

    
        <div class="page-content">
            <div class="search">
    <form role="search" method="get" action="/search/">
         <input name="searchString" class="searchInput" placeholder=" 검색하세요" type="text">
         <input type="submit" class="searchButton" value="Search">
    </form>
</div>
            <div class="post">
                
<input type="hidden" id="thisName" value="cs/data-structure/bst">
<div class="post">
    <header class="post-header">
        <h1 class="page-title">
            <a href="/wiki/cs/data-structure/bst/"> Binary Search Tree </a>
        </h1>
    
        <div class="history-button">
            <p><a href="https://github.com/jxmen/jxmen.github.io/blame/main/_wiki/cs/data-structure/bst.md" target="_blank">created: 2024.03.26</a></p>
            <p><a href="https://github.com/jxmen/jxmen.github.io/blame/main/_wiki/cs/data-structure/bst.md" target="_blank">updated: 2024.04.02</a></p>
            <p>
                <a href="https://github.com/jxmen/jxmen.github.io/edit/main/_wiki/cs/data-structure/bst.md">편집하기</a>
                /
                <a href="https://github.com/jxmen/jxmen.github.io/issues/new?title=Binary+Search+Tree&amp;body=%EC%9D%98%EA%B2%AC%EC%9D%84%20%EB%82%A8%EA%B2%A8%EC%A3%BC%EC%84%B8%EC%9A%94">의견 남기기</a>
            </p>
        </div>

        <div id="parent-list"></div>



    <div class="post-tag">
    
</div>




    </header>
    <article class="post-content">
        <ul id="markdown-toc">
  <li><a href="#bstbinary-search-tree%EB%9E%80" id="markdown-toc-bstbinary-search-tree란">BST(Binary Search Tree)란?</a></li>
  <li><a href="#bst%EC%9D%98-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84" id="markdown-toc-bst의-시간복잡도">BST의 시간복잡도</a></li>
  <li><a href="#%EC%A0%95%EB%A0%AC%EB%90%9C-%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C%EB%8F%84-binary-search%EA%B0%80-%EA%B0%80%EB%8A%A5%ED%95%9C%EB%8D%B0-bst%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94" id="markdown-toc-정렬된-배열에서도-binary-search가-가능한데-bst를-쓰는-이유는">정렬된 배열에서도 Binary Search가 가능한데 BST를 쓰는 이유는?</a></li>
  <li><a href="#bst%EC%9D%98-%EC%82%AD%EC%A0%9C" id="markdown-toc-bst의-삭제">BST의 삭제</a></li>
  <li><a href="#self-balancing" id="markdown-toc-self-balancing">Self-Balancing</a></li>
  <li><a href="#avl-tree" id="markdown-toc-avl-tree">AVL Tree</a></li>
  <li>
<a href="#red-black-tree-rbt" id="markdown-toc-red-black-tree-rbt">Red-Black Tree (RBT)</a>    <ul>
      <li><a href="#%ED%8A%B9%EC%84%B1" id="markdown-toc-특성">특성</a></li>
      <li><a href="#balancing" id="markdown-toc-balancing">Balancing</a></li>
      <li><a href="#%EC%82%BD%EC%9E%85" id="markdown-toc-삽입">삽입</a></li>
      <li><a href="#%EC%82%AD%EC%A0%9C" id="markdown-toc-삭제">삭제</a></li>
    </ul>
  </li>
  <li><a href="#%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" id="markdown-toc-참고자료">참고자료</a></li>
  <li><a href="#todo" id="markdown-toc-todo">ToDo</a></li>
  <li><a href="#%EA%B0%81%EC%A3%BC" id="markdown-toc-각주">각주</a></li>
</ul>

<h3 id="bstbinary-search-tree란">BST(Binary Search Tree)란?</h3>

<p>Binary Tree + 특정한 룰</p>

<ul>
  <li>왼쪽 SubTree는 반드시 지금 노드의 값보다 작은 값</li>
  <li>오른쪽 SubTree는 반드시 지금 노드의 값보다 큰 값</li>
</ul>

<p>예시</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      5
     / \
    /   \
   3     7
  / \
 /   \
1     4
</code></pre></div></div>

<h3 id="bst의-시간복잡도">BST의 시간복잡도</h3>

<p>BST에서 어떤 값이 존재하는지 확인하기 위해서는, 트리의 <strong>최대 깊이</strong>만큼만 탐색해서 찾을 수 있다.</p>

<p>N개의 노드가 밸런싱되어 꽉찬 경우에도 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(logN)</code>이 소요된다.</p>

<h3 id="정렬된-배열에서도-binary-search가-가능한데-bst를-쓰는-이유는">정렬된 배열에서도 Binary Search가 가능한데 BST를 쓰는 이유는?</h3>

<p>이미 정렬된 배열이라도 사실 Binary Search 가 가능하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 2 5 7 9 10 
</code></pre></div></div>

<p>하지만 배열은 삽입/삭제 등은 기존에 저장된 데이터를 밀어내는 과정이 추가로 필요하므로 <code class="language-plaintext highlighter-rouge">O(N)</code>의 시간복잡도를 가지게 된다.</p>

<p>BST는 삽입/삭제 역시 평균적으로 <code class="language-plaintext highlighter-rouge">O(logN)</code>만에 수행할 수 있기 때문에 효과적이다.</p>

<h3 id="bst의-삭제">BST의 삭제</h3>

<p>삭제의 경우가 조금 신경써야 할 부분이 있다. 삭제가 되었을때도 BST의 형태를 유지해야 한다.</p>

<p>자식이 없는 경우 - 삭제할 대상을 NULL로 변경하기만 하면 된다. <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  50         50
 /  \   -&gt;  /  \
30  70    NULL 70
</code></pre></div></div>

<p>자식이 하나만 있는 경우 - 삭제하려는 노드의 자식들을 부모의 자식으로 연결한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    50                    50
   /  \                  /  \
  30  70 (30 제거) -&gt;   40   70
 /
40
</code></pre></div></div>

<p>자식이 둘 다 있는 경우 - 삭제하려는 대상의 오른쪽 자식에서 가장 작은 값으로 대체한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  50                  70
 /  \                /  \
30  80  (50 제거) -&gt; 30  80
   /  \                   \
  70  90                  90
</code></pre></div></div>

<h3 id="self-balancing">Self-Balancing</h3>

<p>극단적으로는 다음과 같은 형태도 BST에 속한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
 \
  2
   \ 
    3...
</code></pre></div></div>

<p>트리의 깊이가 계속해서 깊어져 검색 효율이 좋지 못할 수 있다. 이를 방지하기 위해 밸런스를 알아서 잡는 트리들이 존재한다. 이들은 검색도 항상 <code class="language-plaintext highlighter-rouge">O(logN)</code>의 시간복잡도를 보장하게 된다.</p>

<ul>
  <li>AVL Tree</li>
  <li>Red-Black Tree</li>
</ul>

<h3 id="avl-tree">AVL Tree</h3>

<p><code class="language-plaintext highlighter-rouge">balance factor</code>라는 것을 통해 스스로 균형을 유지한다. balance factor란 어떠한 노드의 왼쪽 서브트리와 오른쪽 서브트리의 값 차이를 말한다.</p>

<p>모든 노드의 balance factor가 {-1, 0, 1}을 충족할 때 AVL Tree가 된다. 밸런스 팩터 체크는 트리의 삽입 혹은 삭제 후 균형을 맞추는 작업을 진행하게 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>50           
 \          70
  70  -&gt;   /  \
   \      50  90
    90
</code></pre></div></div>

<p>balance factor 동작 시 AVL Tree를 만족하면서도 BST를 만족해야 한다. 예를 들어 오른쪽-왼쪽으로 꺾인 트리의 경우는 다음 과정을 통해 균형을 맞추게 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>50      50       
 \       \          60
 70 -&gt;   60  -&gt;    /  \
 /        \       50  70
60        70
</code></pre></div></div>

<p>AVL Tree는 밸런스를 스스로 잡게 되므로, 기존 BST 최악의 경우 <code class="language-plaintext highlighter-rouge">O(N)</code>의 시간복잡도를 <code class="language-plaintext highlighter-rouge">O(logN)</code>으로 개선한다. 다만 밸런스 팩터 동작 과정에서 루트 노드까지 탐색을 하는 과정이 있어 이러한 시간이 걸리는 것도 고려해야 한다.</p>

<h3 id="red-black-tree-rbt">Red-Black Tree (RBT)</h3>

<p>root 노드 black부터 시작하여 black의 자식은 red, 그 자식은 다시 black 번갈아가면서 트리 형태를 유지하는 BST의 일종이다. NULL 대신 nil 노드를 사용한다는 특징이 있다.</p>

<p><img src="/resource//0ccc3561-9cfe-4d06-8429-c0d6c7a19aa5.png" alt="red-black tree"></p>

<h4 id="특성">특성</h4>

<ol>
  <li>모든 노드가 red/black으로 구성된다.</li>
  <li>루트 노드는 항상 black으로 구성된다.</li>
  <li>모든 leaf 노드는 null 대신 nil 노드라는 개념을 사용한다. nil 노드는 항상 블랙이고 red/black 노드와 동등하게 취급한다.</li>
  <li>red의 자식은 black이다. 그리고 red가 연속적으로 존재할 수 없다.</li>
  <li>임의의 노드에서 nil 노드까지 가는 모든 경로의 black의 개수는 같다. (노드 x의 모든 nil 노드까지의 경로는 black height가 모두 같다.)</li>
</ol>

<h4 id="balancing">Balancing</h4>

<p>삽입/삭제 시 Red-Black Tree의 특성을 위반할 경우 트리 구조를 재조정한다.</p>

<h4 id="삽입">삽입</h4>

<p>삽입하는 노드의 색은 항상 Red이다. RBT의 black height 특성을 유지하기 위해서이다.</p>

<p>삽입 후에 RBT의 형태를 유지하고 있는지 체크한다. 삽입 시 발생하는 RBT 위반 케이스는 크게 3가지로 나뉘며, 이에 따라 다르게 트리가 조정된다.</p>

<h4 id="삭제">삭제</h4>

<p>BST 삭제와 동일하게 동작한다. 이후 RBT의 속성을 위반했는지 체크하고, 일치하지 않다면 다시 재조정을 진행한다.</p>

<p>삭제의 경우 <strong>어떤 색이 삭제되는가</strong>가 속성 위반 여부를 판단하는데에 중요하다.</p>

<ul>
  <li>삭제하려는 노드의 자녀가 없거나 하나라면 바로 삭제된다.</li>
  <li>삭제하려는 노드의 자녀가 둘이라면 삭제되는 노드의 successor의 색이 삭제된다. <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup>
</li>
</ul>

<p>삭제되는 색이 Red일 경우 어떠한 속성도 위반하지 않는다.</p>

<p>다만 삭제하려는 색이 Black일 경우, 임시로 extra black이라는 것으로 black으로 취급 후 재조정을 진행한다.(자세한 내용은 중략…) <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup></p>

<h3 id="참고자료">참고자료</h3>

<ul>
  <li><a href="https://www.youtube.com/watch?v=wQwB5gdnEDg">코맹탈출 - 자료구조 Binary Search Tree</a></li>
  <li><a href="https://www.youtube.com/watch?v=syGPNOhsnI4">쉬운코드 - AVL 트리</a></li>
  <li><a href="https://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC">위키백과 - 레드-블랙 트리</a></li>
  <li><a href="https://www.youtube.com/watch?v=2MdsebfJOyM&list=PPSV">쉬운코드 - 레드-블랙 트리 1</a></li>
  <li><a href="https://www.youtube.com/watch?v=6drLl777k-E&list=PPSV">쉬운코드 - 레드-블랙 트리 2</a></li>
</ul>

<h3 id="todo">ToDo</h3>

<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>BST 삽입 내용 추가</li>
</ul>

<h3 id="각주">각주</h3>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>교과서적인 용어로는 <code class="language-plaintext highlighter-rouge">rotate</code>라고 한다. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>successor: 이진트리에서 어떤 노드의 바로 다음 큰 값을 의미한다. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://www.youtube.com/watch?v=6drLl777k-E&list=PPSV">https://www.youtube.com/watch?v=6drLl777k-E&list=PPSV</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

    </article>


    
<div class="giscus"></div>
<div class="post-comments">
  <script src="https://giscus.app/client.js" data-repo="jxmen/jxmen.github.io" data-repo-id="R_kgDOLKyoHA" data-category="Comments" data-category-id="DIC_kwDOLKyoHM4CdGSe" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="noborder_light" data-lang="ko" crossorigin="anonymous" async></script>
</div>




</div>
<script async src="/js/create-link.js"></script>


<script async>
    ;(function() {
        const tableList = document.querySelectorAll('.table-generate');

        if (tableList == null) {
            return;
        }

        for (let i = 0; i < tableList.length; i++) {
            const ul = tableList[i];
            const draw = {
                th: '',
                td: ''
            };

            const rows = ul.children;
            for (let j = 0; j < rows.length; j++) {
                const row = rows[j].children[0];
                const columns = row.children;
                const isHeader = /^th/.test(rows[j].innerHTML);
                const colTag = isHeader ? 'th' : 'td';

                let colData = '';
                for (let k = 0; k < columns.length; k++) {
                    const column = columns[k];
                    const content = column.innerHTML;
                    colData += `<${colTag}>${content}</${colTag}>`;
                }

                const trHtml = `<tr>${colData}</tr>`

                draw[colTag] += trHtml;
            }

            const result = `
                <table>
                    <thead>${draw.th}</thead>
                    <tbody>${draw.td}</tbody>
                </table>`

            const targetId = ul.getAttribute('data-target-id');
            document.getElementById(targetId).innerHTML = result;
            ul.remove();
        }
    })();
    ;(function() {
        const source = document.querySelectorAll('.dynamic-insert');

        if (source == null) {
            return;
        }

        for (let i = 0; i < source.length; i++) {
            const item = source[i];

            const target = item.getAttribute('data-target-selector');
            document.querySelector(target).innerHTML = item.outerHTML;
            item.remove();
        }
    })();
</script>


<script async src="/js/parent.js"></script>
<script async src="/js/toc-highlight.js"></script>

            </div>
        </div>
        <footer class="footer">
    <div>

    </div>

</footer>
    
</body>
</html>
